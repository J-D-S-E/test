Repository: studioimaginaire/phue
File: .gitignore

*.pyc
*~
*.swp
test.py
*.DS_Store
*.sublime-workspace
dist
MANIFEST


Repository: studioimaginaire/phue
File: .travis.yml

language: python
matrix:
  fast_finish: true
  include:
    - python: "2.7"
      env: TOXENV=py27
    - python: "3.5"
      env: TOXENV=py35
    - python: "2.7"
      env: TOXENV=pep8
install: pip install tox
script: tox


Repository: studioimaginaire/phue
File: CHANGELOG.md

# phue changelog

## r11
- Add support for deleting scenes
- Various bug fixes

## r10
- Misc bug fixes
- Better support for schedules

## r9
- Added unit tests (sdague)
- Added scene support (sdague)
- Added sensor support (eldstal)
- Added reachable and type attributes to the Light object (carlosperate)
- Changed License to MIT

## r8
- iOS compatibility (Nathanaël Lécaudé)
- Logging fixes
- Added effect changing options (bradykent)
- Several unicode fixes (Nathanaël Lécaudé)
- Misc bug fixes

## r7
- Added to pypi
- Added support for Python 3 (Nathanaël Lécaudé)
- Logging level can be set with b.set_logging() (Nathanaël Lécaudé)
- Logging level can be set at init: b = Bridge(logging = 'debug') (Nathanaël Lécaudé)
- Added docstrings to Light properties (Nathanaël Lécaudé)
- Added colormode property to Light class (Nathanaël Lécaudé)
- IP is now optional if present in config file (Nathanaël Lécaudé)
- Implemented groups (Nathanaël Lécaudé)
- Implemented schedules (Nathanaël Lécaudé)
- Renamed get_info to get_api (Nathanaël Lécaudé)
- Renamed get_lights to get_light_objects (Nathanaël Lécaudé)
- Renamed set_state and get_state to set_light and get_light (Nathanaël Lécaudé)
- Fixed important bug when using set_state with a list of lights (Nathanaël Lécaudé)
- Add access to Light objects via direct indexing of the Bridge object via __getitem__ (Marshall Perrin)
- Implement real logging using Python's logging module, including error checking and display of responses from the server. (Marshall Perrin)
- Add function colortemp_k for color temperatures in Kelvin. (Marshall Perrin)
- Some additional error checking for invalid or missing parameters (Marshall Perrin)
- More details in docstrings. (Marshall Perrin)


## r6
- Light objects are now obtained using the get_lights method
- Added the alert method to the Light object
- All requests now use httplib for consistency
- Moved all source to github
- Renamed the module to phue

## r5
 - Renamed the Bulb() object to Light() so it reflects the official API better
 - You can now pass the username as argument to the Bridge class if you don't want to read/store to file
 - You can now get the bridge name with brdige.name or set it with bridge.name = 'newname'
 - The set_state method can now use a dictionary as first argument to send more complex messages


Repository: studioimaginaire/phue
File: LICENSE

The MIT License (MIT)

Copyright (c) 2014 Nathanaël Lécaudé
https://github.com/studioimaginaire/phue

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


Repository: studioimaginaire/phue
File: README.md

# phue: A Python library for Philips Hue

Full featured Python library to control the Philips Hue lighting system.

## Features

- Compliant with the Philips Hue API 1.0
- Support for Lights
- Support for Groups
- Support for Schedules
- Support for Scenes
- Support for Sensors
- Compatible with Python 2.6.x and upwards
- Compatible with Python 3
- No dependencies
- Simple structure, single phue.py file
- Work in a procedural way or object oriented way

## Installation

### Using distutils

```
sudo easy_install phue
```
or
```
pip install phue
```

### Manually

phue consists of a single file (phue.py) that you can put in your python search path or in site-packages (or dist-packages depending on the platform)
You can also simply run it by putting it in the same directory as you main script file or start a python interpreter in the same directory.
phue works with Python 2.6.x, 2.7.x and 3.x

## Examples

### Basic usage

Using the set_light and get_light methods you can control pretty much all the parameters :

```python
#!/usr/bin/python

from phue import Bridge

b = Bridge('ip_of_your_bridge')

# If the app is not registered and the button is not pressed, press the button and call connect() (this only needs to be run a single time)
b.connect()

# Get the bridge state (This returns the full dictionary that you can explore)
b.get_api()

# Prints if light 1 is on or not
b.get_light(1, 'on')

# Set brightness of lamp 1 to max
b.set_light(1, 'bri', 254)

# Set brightness of lamp 2 to 50%
b.set_light(2, 'bri', 127)

# Turn lamp 2 on
b.set_light(2,'on', True)

# You can also control multiple lamps by sending a list as lamp_id
b.set_light( [1,2], 'on', True)

# Get the name of a lamp
b.get_light(1, 'name')

# You can also use light names instead of the id
b.get_light('Kitchen')
b.set_light('Kitchen', 'bri', 254)

# Also works with lists
b.set_light(['Bathroom', 'Garage'], 'on', False)

# The set_light method can also take a dictionary as the second argument to do more fancy stuff
# This will turn light 1 on with a transition time of 30 seconds
command =  {'transitiontime' : 300, 'on' : True, 'bri' : 254}
b.set_light(1, command)
```

### Light Objects

If you want to work in a more object-oriented way, there are several ways you can get Light objects.

#### Get a flat list of light objects
```python

lights = b.lights

# Print light names
for l in lights:
    print(l.name)

# Set brightness of each light to 127
for l in lights:
    l.brightness = 127

```

#### Get Light objects as dictionaries

```python
# Get a dictionary with the light id as the key
lights = b.get_light_objects('id')

# Get the name of light 1, set the brightness to 127
lights[1].name
lights[1].brightness = 127

# Get a dictionary with the light name as the key
light_names = b.get_light_objects('name')

# Set the brightness of the bulb named "Kitchen"
light_names["Kitchen"].brightness = 254

# Set lights using name as key
for light in ['Kitchen', 'Bedroom', 'Garage']
    light_names[light].on = True
    light_names[light].hue = 15000
    light_names[light].saturation = 120

# Get a flat list of the light objects (same as calling b.lights)
lights_list = b.get_light_objects('list')

for light in lights_list:
   light.on = True
   light.brightness = 127

```

### Setting Transition Times

In the Hue API, transition times are specified in deciseconds (tenths
of a second). This
is not tracked as a device setting, but rather needs to be applied on
each individual transition command you want to control the time of.

This can be done by specifying a transitiontime keyword when calling
set_light on the bridge:


```python
# Set brightness of lamp 1 to max, rapidly
b.set_light(1, 'bri', 254, transitiontime=1)
```

As a convenience, the Light class implements a wrapper that remembers
a specified transition time for that light, and applies it
automatically to every transition:

```python
light = light_names['Kitchen']
light.transitiontime = 2
# this next transition will happen rapidly
light.brightness = 20    
```

Note that there is a known bug where turning a light off with the
transitiontime specified can cause the brightness level to behave
erratically when the light is turned back on. See [this
discussion](http://www.everyhue.com/vanilla/discussion/204/bug-with-brightness-when-requesting-ontrue-transitiontime5)
This package attempts to work around this issue by automatically
resetting the brightness when necessary, but this may not work in all
cases.

Transition times from 0-300 deciseconds (i.e. 0 - 30 seconds) have
been tested to work.

### Groups

You can also work with the groups functionality of the Bridge. If groups aren't working, try re-setting the bridge by unpluging it and plugging it back again.

```python

# List groups
b.get_group()

# List group 1
b.get_group(1)

# Get name of group 1
b.get_group(1, 'name')

# Get lights in group 1
b.get_group(1,'lights')

# Create a group with lights 1 and 3
b.create_group('Kitchen', [1,3])

# Rename group with id 1
b.set_group(1, 'name', 'New Group Name')

# Change lights within group 1
b.set_group(1, 'lights', [3,4])

# Turn group 1 off
b.set_group(1, 'on', False)

# Delete group 2
b.delete_group(1)

```

### Schedules

You can view, create and delete schedules using the following methods. Note that updates to the Hue API now use local time instead of UTC. If you have issues with schedules not triggering correctly, double check that the time zone is set correctly on your Hue Bridge and that your time in your code is not in UTC by default.

```python

# Get the list of different schedules
b.get_schedule()

# Get the data of a particular schedules
b.get_schedule(1)

# Create a schedule for a light, arguments are name, time, light_id, data (as a dictionary) and optional description
data = {'on': False, 'transitiontime': 600}
b.create_schedule('My schedule', '2012-11-12T22:34:00', 1, data, 'Bedtime' )

# Create a schedule for a group, same as above but with a group_id instead of light_id
data = {'on': False, 'transitiontime': 600}
b.create_group_schedule('My schedule', '2012-11-12T22:34:00', 0, data, 'Bedtime' )

# Delete a schedule
b.delete_schedule(1)

```

## Using phue with Max/MSP via Jython

You can use the phue library within [Max/MSP](http://www.cycling74.com) by using [Nick Rothwell's](http://www.cassiel.com) Jython objects.  He recently updated the version to support Jython 2.7 which is required for phue to work.

Download it here: https://github.com/cassiel/net.loadbang.jython

## Using phue on iOS via Pythonista

You can use phue on your iOS device via the [Pythonista](http://omz-software.com/pythonista) app.
This is a great way to build quick prototypes on iOS as you don't need to compile anything, you can code directly from the device itself.

See this little example:

http://www.youtube.com/embed/6K-fxWG6JSs

## Acknowledgments

Huge thanks to http://rsmck.co.uk/hue for hacking the protocol !

## License

MIT - http://opensource.org/licenses/MIT

"Hue Personal Wireless Lighting" is a trademark owned by Koninklijke Philips Electronics N.V., see www.meethue.com for more information.
I am in no way affiliated with the Philips organization.


Repository: studioimaginaire/phue
File: TODO.md

#phue TODO

 * Find a more elegant way to deal with transitiontime
 * Add a Group class
 * Cleanup the connect and register_app methods
 * ~~Replace prints with proper logging mechanism~~
 * ~~Read/Write config file from cwd if home is not writable~~
 * ~~Store IP in config file~~
 * ~~Add support for groups~~
 * ~~Make username passable as argument and config file optional (so it can run when no write access is present like on iphone)~~
 * ~~Rename Bulb to Light to conform to API~~ (done)
 * ~~Add the ability to get and set the bridge name~~ (done)
 * ~~Update Bulbs dictionary when lights are renamed~~ (done)


Repository: studioimaginaire/phue
File: examples/flicker.py

import random
from time import sleep
from phue import Bridge
b = Bridge('192.168.0.23')
b.connect()
lights = b.lights

def select_multiple_lights():
  '''
  Selects a random number of lights from the list of lights every time, resulting in a 'flickering' look.
  '''
  return random.choices(range(1,len(lights)+1),k=random.randint(1,len(lights)))

def multi_modal():
      '''
      Generates a random transition time between 0.2 and 0.7 seconds folowing a multi-modal distribution.
      This results in really fast transitions, but also slow transitions.
      '''
      return [2+int(random.betavariate(1,9)*5),2+int(random.betavariate(9,1)*5)][bool(random.getrandbits(1))]

def candle_flicker():
  '''
  Sends a command to change a certain number of lights a different color temperature every time. ct_inc was finicky, so I've used ct instead.
  All inputs use a beta distribution, as it looked more natural. A similar look can be achieved using a triangular distribution as well.
  '''
  b.set_light(select_multiple_lights(), {'transitiontime' : multi_modal(), 'on' : True, 'bri' : 1+int(random.betavariate(2,5)*253), 'ct' : 153+int(random.betavariate(9,4)*347)})
  
while True:
  candle_flicker()
  sleep(random.random())


Repository: studioimaginaire/phue
File: examples/hue-rainbow.py

#!/usr/bin/python
# This script will have all lights, which are on, continuously loop through the rainbow 
# in the time specified in totalTime
from phue import Bridge
import random

b = Bridge() # Enter bridge IP here.

# If running for the first time, press button on bridge and run with b.connect() uncommented
# b.connect()

lights = b.get_light_objects()

totalTime = 30 # in seconds
transitionTime = 1 # in seconds

maxHue = 65535
hueIncrement = maxHue / totalTime

for light in lights:
    light.transitiontime = transitionTime * 10
    light.brightness = 254
    light.saturation = 254
    # light.on = True # uncomment to turn all lights on

hue = 0
while True:
    for light in lights:
	      light.hue = hue

    hue = (hue + hueIncrement) % maxHue

    sleep(transitionTime)


Repository: studioimaginaire/phue
File: examples/random_colors.py

#!/usr/bin/python
from phue import Bridge
import random

b = Bridge() # Enter bridge IP here.

#If running for the first time, press button on bridge and run with b.connect() uncommented
#b.connect()

lights = b.get_light_objects()

for light in lights:
	light.brightness = 254
	light.xy = [random.random(),random.random()]




Repository: studioimaginaire/phue
File: examples/rgb_colors.py

#!/usr/bin/python
from phue import Bridge

def rgb_to_xy(red, green, blue):
    """ conversion of RGB colors to CIE1931 XY colors
    Formulas implemented from: https://gist.github.com/popcorn245/30afa0f98eea1c2fd34d

    Args: 
        red (float): a number between 0.0 and 1.0 representing red in the RGB space
        green (float): a number between 0.0 and 1.0 representing green in the RGB space
        blue (float): a number between 0.0 and 1.0 representing blue in the RGB space

    Returns:
        xy (list): x and y
    """

    # gamma correction
    red = pow((red + 0.055) / (1.0 + 0.055), 2.4) if red > 0.04045 else (red / 12.92)
    green = pow((green + 0.055) / (1.0 + 0.055), 2.4) if green > 0.04045 else (green / 12.92)
    blue =  pow((blue + 0.055) / (1.0 + 0.055), 2.4) if blue > 0.04045 else (blue / 12.92)

    # convert rgb to xyz
    x = red * 0.649926 + green * 0.103455 + blue * 0.197109
    y = red * 0.234327 + green * 0.743075 + blue * 0.022598
    z = green * 0.053077 + blue * 1.035763

    # convert xyz to xy
    x = x / (x + y + z)
    y = y / (x + y + z)

    # TODO check color gamut if known
     
    return [x, y]


b = Bridge() # Enter bridge IP here.

#If running for the first time, press button on bridge and run with b.connect() uncommented
#b.connect()

# RGB colors to XY  
xy = rgb_to_xy(1.0, 0.28627, 0.95686)

lights = b.get_light_objects()

for light in lights:
    # y might be used as brightness value, however, dark colors will turn the lights off
    #brightness = int(xy[1]*255)
    brightness = 255 
    light.xy = xy 


Repository: studioimaginaire/phue
File: examples/tk_gui_complex.py

#!/usr/bin/python
from Tkinter import *
from phue import Bridge

'''
This example creates 3 sliders for the first 3 lights
and shows the name of the light under each slider.
There is also a checkbox to toggle the light.
'''

b = Bridge() # Enter bridge IP here.

#If running for the first time, press button on bridge and run with b.connect() uncommented
#b.connect()

root = Tk()

horizontal_frame = Frame(root)
horizontal_frame.pack()

lights = b.get_light_objects('id')

for light_id in lights:
    channel_frame = Frame(horizontal_frame)
    channel_frame.pack(side = LEFT)

    scale_command = lambda x, light_id=light_id: b.set_light(light_id,{'bri': int(x), 'transitiontime': 1})
    scale = Scale(channel_frame, from_ = 254, to = 0, command = scale_command, length = 200, showvalue = 0)
    scale.set(b.get_light(light_id,'bri'))
    scale.pack()

    button_var = BooleanVar()
    button_var.set(b.get_light(light_id, 'on'))
    button_command = lambda button_var=button_var, light_id=light_id: b.set_light(light_id, 'on', button_var.get())
    button = Checkbutton(channel_frame, variable = button_var, command = button_command)
    button.pack()

    label = Label(channel_frame)
    label.config(text = b.get_light(light_id,'name'))
    label.pack()

root.mainloop()

Repository: studioimaginaire/phue
File: examples/tk_gui_hsb.py

#!/usr/bin/python
from Tkinter import *
from phue import Bridge

'''
This example creates 3 sliders for the first 3 lights
and shows the name of the light under each slider.
There is also a checkbox to toggle the light.
'''

b = Bridge() # Enter bridge IP here.

#If running for the first time, press button on bridge and run with b.connect() uncommented
#b.connect()

root = Tk()

lights = b.get_light_objects('id')
light_selection = []


def curry(fn, *cargs, **ckwargs):
    def call_fn(*fargs, **fkwargs):
        d = ckwargs.copy()
        d.update(fkwargs)
        return fn(*(cargs + fargs), **d)
    return call_fn

def hue_command(x):
    if len(light_selection) > 0:
        b.set_light(light_selection, 'hue', int(x))
def sat_command(x):
    if len(light_selection) > 0:
        b.set_light(light_selection, 'sat', int(x))
def bri_command(x):
    if len(light_selection) > 0:
        b.set_light(light_selection, 'bri', int(x))

def select_button_command(light, button_state):
    global light_selection
    if button_state.get():
        light_selection.append(light)
    else:
        light_selection.remove(light)
    print light_selection

slider_frame = Frame(root)
slider_frame.pack(pady = 10)

channels_frame = Frame(root)
channels_frame.pack()

label_frame = Frame(channels_frame)
label_frame.pack(side=LEFT, padx = 10)

label_state = Label(label_frame)
label_state.config(text = 'State')
label_state.pack()

label_select = Label(label_frame)
label_select.config(text = 'Select')
label_select.pack()

label_name = Label(label_frame)
label_name.config(text = 'Name')
label_name.pack()

hue_slider = Scale(slider_frame, from_ = 65535, to = 0, command = hue_command)
sat_slider = Scale(slider_frame, from_ = 254, to = 0, command = sat_command)
bri_slider = Scale(slider_frame, from_ = 254, to = 0, command = bri_command)
hue_slider.pack(side=LEFT)
sat_slider.pack(side=LEFT)
bri_slider.pack(side=LEFT)


for light_id in lights:
    channel_frame = Frame(channels_frame)
    channel_frame.pack(side = LEFT, padx = 10)
    
    button_var = BooleanVar()
    button_var.set(b.get_light(light_id, 'on'))
    button_command = lambda button_var=button_var, light_id=light_id: b.set_light(light_id, 'on', button_var.get())
    button = Checkbutton(channel_frame, variable = button_var, command = button_command)
    button.pack()

    select_button_var = BooleanVar()
    #select_button_var.set(b.get_light(light_id, 'on'))
    select_button_callback = curry(select_button_command, light_id, select_button_var)
    select_button = Checkbutton(channel_frame, variable = select_button_var, command = select_button_callback)
    select_button.pack()

    label = Label(channel_frame)
    label.config(text = b.get_light(light_id,'name'))
    label.pack()

root.mainloop()

Repository: studioimaginaire/phue
File: examples/tk_gui_simple.py

#!/usr/bin/python
from Tkinter import *
from phue import Bridge

'''
This example creates a slider that controls the
brightness of the first 3 lights.
'''

b = Bridge() # Enter bridge IP here.

#If running for the first time, press button on bridge and run with b.connect() uncommented
#b.connect()

b.set_light([1,2,3], 'on', True)

def sel(data):
    b.set_light([1,2,3],{'bri':int(data), 'transitiontime': 1})

root = Tk()
scale = Scale( root, from_ = 254, to = 0, command= sel, length = 200 )
scale.set(b.get_light(1,'bri'))
scale.pack(anchor=CENTER)

root.mainloop()

Repository: studioimaginaire/phue
File: phue.py

#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
phue by Nathanaël Lécaudé - A Philips Hue Python library
Contributions by Marshall Perrin, Justin Lintz
https://github.com/studioimaginaire/phue
Original protocol hacking by rsmck : http://rsmck.co.uk/hue

Published under the MIT license - See LICENSE file for more details.

"Hue Personal Wireless Lighting" is a trademark owned by Koninklijke Philips Electronics N.V., see www.meethue.com for more information.
I am in no way affiliated with the Philips organization.

'''

import json
import logging
import os
import platform
import sys
import socket
if sys.version_info[0] > 2:
    PY3K = True
else:
    PY3K = False

if PY3K:
    import http.client as httplib
else:
    import httplib

logger = logging.getLogger('phue')


if platform.system() == 'Windows':
    USER_HOME = 'USERPROFILE'
else:
    USER_HOME = 'HOME'

__version__ = '1.2'


def is_string(data):
    """Utility method to see if data is a string."""
    if PY3K:
        return isinstance(data, str)
    else:
        return isinstance(data, str) or isinstance(data, unicode)  # noqa

def encodeString(string):
    """Utility method to encode strings as utf-8."""
    if PY3K:
        return string
    else:
        return string.encode('utf-8')

def decodeString(string):
    """Utility method to decode strings as utf-8."""
    if PY3K:
        return string
    else:
        return string.decode('utf-8')

class PhueException(Exception):

    def __init__(self, id, message):
        self.id = id
        self.message = message


class PhueRegistrationException(PhueException):
    pass


class PhueRequestTimeout(PhueException):
    pass


class Light(object):

    """ Hue Light object

    Light settings can be accessed or set via the properties of this object.

    """
    def __init__(self, bridge, light_id):
        self.bridge = bridge
        self.light_id = light_id

        self._name = None
        self._on = None
        self._brightness = None
        self._colormode = None
        self._hue = None
        self._saturation = None
        self._xy = None
        self._colortemp = None
        self._effect = None
        self._alert = None
        self.transitiontime = None  # default
        self._reset_bri_after_on = None
        self._reachable = None
        self._type = None

    def __repr__(self):
        # like default python repr function, but add light name
        return '<{0}.{1} object "{2}" at {3}>'.format(
            self.__class__.__module__,
            self.__class__.__name__,
            self.name,
            hex(id(self)))

    # Wrapper functions for get/set through the bridge, adding support for
    # remembering the transitiontime parameter if the user has set it
    def _get(self, *args, **kwargs):
        return self.bridge.get_light(self.light_id, *args, **kwargs)

    def _set(self, *args, **kwargs):

        if self.transitiontime is not None:
            kwargs['transitiontime'] = self.transitiontime
            logger.debug("Setting with transitiontime = {0} ds = {1} s".format(
                self.transitiontime, float(self.transitiontime) / 10))

            if (args[0] == 'on' and args[1] is False) or (
                    kwargs.get('on', True) is False):
                self._reset_bri_after_on = True
        return self.bridge.set_light(self.light_id, *args, **kwargs)

    @property
    def name(self):
        '''Get or set the name of the light [string]'''
        return encodeString(self._get('name'))

    @name.setter
    def name(self, value):
        old_name = self.name
        self._name = value
        self._set('name', self._name)

        logger.debug("Renaming light from '{0}' to '{1}'".format(
            old_name, value))

        self.bridge.lights_by_name[self.name] = self
        del self.bridge.lights_by_name[old_name]

    @property
    def on(self):
        '''Get or set the state of the light [True|False]'''
        self._on = self._get('on')
        return self._on

    @on.setter
    def on(self, value):

        # Some added code here to work around known bug where
        # turning off with transitiontime set makes it restart on brightness = 1
        # see
        # http://www.everyhue.com/vanilla/discussion/204/bug-with-brightness-when-requesting-ontrue-transitiontime5

        # if we're turning off, save whether this bug in the hardware has been
        # invoked
        if self._on and value is False:
            self._reset_bri_after_on = self.transitiontime is not None
            if self._reset_bri_after_on:
                logger.warning(
                    'Turned off light with transitiontime specified, brightness will be reset on power on')

        self._set('on', value)

        # work around bug by resetting brightness after a power on
        if self._on is False and value is True:
            if self._reset_bri_after_on:
                logger.warning(
                    'Light was turned off with transitiontime specified, brightness needs to be reset now.')
                self.brightness = self._brightness
                self._reset_bri_after_on = False

        self._on = value

    @property
    def colormode(self):
        '''Get the color mode of the light [hs|xy|ct]'''
        self._colormode = self._get('colormode')
        return self._colormode

    @property
    def brightness(self):
        '''Get or set the brightness of the light [0-254].

        0 is not off'''

        self._brightness = self._get('bri')
        return self._brightness

    @brightness.setter
    def brightness(self, value):
        self._brightness = value
        self._set('bri', self._brightness)

    @property
    def hue(self):
        '''Get or set the hue of the light [0-65535]'''
        self._hue = self._get('hue')
        return self._hue

    @hue.setter
    def hue(self, value):
        self._hue = int(value)
        self._set('hue', self._hue)

    @property
    def saturation(self):
        '''Get or set the saturation of the light [0-254]

        0 = white
        254 = most saturated
        '''
        self._saturation = self._get('sat')
        return self._saturation

    @saturation.setter
    def saturation(self, value):
        self._saturation = value
        self._set('sat', self._saturation)

    @property
    def xy(self):
        '''Get or set the color coordinates of the light [ [0.0-1.0, 0.0-1.0] ]

        This is in a color space similar to CIE 1931 (but not quite identical)
        '''
        self._xy = self._get('xy')
        return self._xy

    @xy.setter
    def xy(self, value):
        self._xy = value
        self._set('xy', self._xy)

    @property
    def colortemp(self):
        '''Get or set the color temperature of the light, in units of mireds [154-500]'''
        self._colortemp = self._get('ct')
        return self._colortemp

    @colortemp.setter
    def colortemp(self, value):
        if value < 154:
            logger.warn('154 mireds is coolest allowed color temp')
        elif value > 500:
            logger.warn('500 mireds is warmest allowed color temp')
        self._colortemp = value
        self._set('ct', self._colortemp)

    @property
    def colortemp_k(self):
        '''Get or set the color temperature of the light, in units of Kelvin [2000-6500]'''
        self._colortemp = self._get('ct')
        return int(round(1e6 / self._colortemp))

    @colortemp_k.setter
    def colortemp_k(self, value):
        if value > 6500:
            logger.warn('6500 K is max allowed color temp')
            value = 6500
        elif value < 2000:
            logger.warn('2000 K is min allowed color temp')
            value = 2000

        colortemp_mireds = int(round(1e6 / value))
        logger.debug("{0:d} K is {1} mireds".format(value, colortemp_mireds))
        self.colortemp = colortemp_mireds

    @property
    def effect(self):
        '''Check the effect setting of the light. [none|colorloop]'''
        self._effect = self._get('effect')
        return self._effect

    @effect.setter
    def effect(self, value):
        self._effect = value
        self._set('effect', self._effect)

    @property
    def alert(self):
        '''Get or set the alert state of the light [select|lselect|none]'''
        self._alert = self._get('alert')
        return self._alert

    @alert.setter
    def alert(self, value):
        if value is None:
            value = 'none'
        self._alert = value
        self._set('alert', self._alert)

    @property
    def reachable(self):
        '''Get the reachable state of the light [boolean]'''
        self._reachable = self._get('reachable')
        return self._reachable

    @property
    def type(self):
        '''Get the type of the light [string]'''
        self._type = self._get('type')
        return self._type


class SensorState(dict):
    def __init__(self, bridge, sensor_id):
        self._bridge = bridge
        self._sensor_id = sensor_id

    def __setitem__(self, key, value):
        dict.__setitem__(self, key, value)
        self._bridge.set_sensor_state(self._sensor_id, self)


class SensorConfig(dict):
    def __init__(self, bridge, sensor_id):
        self._bridge = bridge
        self._sensor_id = sensor_id

    def __setitem__(self, key, value):
        dict.__setitem__(self, key, value)
        self._bridge.set_sensor_config(self._sensor_id, self)


class Sensor(object):

    """ Hue Sensor object

    Sensor config and state can be read and updated via the properties of this object

    """
    def __init__(self, bridge, sensor_id):
        self.bridge = bridge
        self.sensor_id = sensor_id

        self._name = None
        self._model = None
        self._swversion = None
        self._type = None
        self._uniqueid = None
        self._manufacturername = None
        self._state = SensorState(bridge, sensor_id)
        self._config = {}
        self._recycle = None

    def __repr__(self):
        # like default python repr function, but add sensor name
        return '<{0}.{1} object "{2}" at {3}>'.format(
            self.__class__.__module__,
            self.__class__.__name__,
            self.name,
            hex(id(self)))

    # Wrapper functions for get/set through the bridge
    def _get(self, *args, **kwargs):
        return self.bridge.get_sensor(self.sensor_id, *args, **kwargs)

    def _set(self, *args, **kwargs):
        return self.bridge.set_sensor(self.sensor_id, *args, **kwargs)

    @property
    def name(self):
        '''Get or set the name of the sensor [string]'''
        return encodeString(self._get('name'))

    @name.setter
    def name(self, value):
        old_name = self.name
        self._name = value
        self._set('name', self._name)

        logger.debug("Renaming sensor from '{0}' to '{1}'".format(
            old_name, value))

        self.bridge.sensors_by_name[self.name] = self
        del self.bridge.sensors_by_name[old_name]

    @property
    def modelid(self):
        '''Get a unique identifier of the hardware model of this sensor [string]'''
        self._modelid = self._get('modelid')
        return self._modelid

    @property
    def swversion(self):
        '''Get the software version identifier of the sensor's firmware [string]'''
        self._swversion = self._get('swversion')
        return self._swversion

    @property
    def type(self):
        '''Get the sensor type of this device [string]'''
        self._type = self._get('type')
        return self._type

    @property
    def uniqueid(self):
        '''Get the unique device ID of this sensor [string]'''
        self._uniqueid = self._get('uniqueid')
        return self._uniqueid

    @property
    def manufacturername(self):
        '''Get the name of the manufacturer [string]'''
        self._manufacturername = self._get('manufacturername')
        return self._manufacturername

    @property
    def state(self):
        ''' A dictionary of sensor state. Some values can be updated, some are read-only. [dict]'''
        data = self._get('state')
        self._state.clear()
        self._state.update(data)
        return self._state

    @state.setter
    def state(self, data):
        self._state.clear()
        self._state.update(data)

    @property
    def config(self):
        ''' A dictionary of sensor config. Some values can be updated, some are read-only. [dict]'''
        data = self._get('config')
        self._config.clear()
        self._config.update(data)
        return self._config

    @config.setter
    def config(self, data):
        self._config.clear()
        self._config.update(data)

    @property
    def recycle(self):
        ''' True if this resource should be automatically removed when the last reference to it disappears [bool]'''
        self._recycle = self._get('manufacturername')
        return self._manufacturername


class Group(Light):

    """ A group of Hue lights, tracked as a group on the bridge

    Example:

        >>> b = Bridge()
        >>> g1 = Group(b, 1)
        >>> g1.hue = 50000 # all lights in that group turn blue
        >>> g1.on = False # all will turn off

        >>> g2 = Group(b, 'Kitchen')  # you can also look up groups by name
        >>> # will raise a LookupError if the name doesn't match

    """

    def __init__(self, bridge, group_id):
        Light.__init__(self, bridge, None)
        del self.light_id  # not relevant for a group
        self._any_on = None
        self._all_on = None

        try:
            self.group_id = int(group_id)
        except:
            name = group_id
            groups = bridge.get_group()
            for idnumber, info in groups.items():
                if info['name'] == decodeString(name):
                    self.group_id = int(idnumber)
                    break
            else:
                raise LookupError("Could not find a group by that name.")

    # Wrapper functions for get/set through the bridge, adding support for
    # remembering the transitiontime parameter if the user has set it
    def _get(self, *args, **kwargs):
        return self.bridge.get_group(self.group_id, *args, **kwargs)

    def _set(self, *args, **kwargs):
        # let's get basic group functionality working first before adding
        # transition time...
        if self.transitiontime is not None:
            kwargs['transitiontime'] = self.transitiontime
            logger.debug("Setting with transitiontime = {0} ds = {1} s".format(
                self.transitiontime, float(self.transitiontime) / 10))

            if (args[0] == 'on' and args[1] is False) or (
                    kwargs.get('on', True) is False):
                self._reset_bri_after_on = True
        return self.bridge.set_group(self.group_id, *args, **kwargs)

    @property
    def name(self):
        '''Get or set the name of the light group [string]'''
        return encodeString(self._get('name'))

    @name.setter
    def name(self, value):
        old_name = self.name
        self._name = value
        logger.debug("Renaming light group from '{0}' to '{1}'".format(
            old_name, value))
        self._set('name', self._name)

    @property
    def any_on(self):
        """If true at least one light in the group is on"""
        self._any_on = self._get('any_on')
        return self._any_on

    @property
    def all_on(self):
        """If true all lights in the group are on"""
        self._all_on = self._get('all_on')
        return self._all_on

    @property
    def lights(self):
        """ Return a list of all lights in this group"""
        # response = self.bridge.request('GET', '/api/{0}/groups/{1}'.format(self.bridge.username, self.group_id))
        # return [Light(self.bridge, int(l)) for l in response['lights']]
        return [Light(self.bridge, int(l)) for l in self._get('lights')]

    @lights.setter
    def lights(self, value):
        """ Change the lights that are in this group"""
        logger.debug("Setting lights in group {0} to {1}".format(
            self.group_id, str(value)))
        self._set('lights', value)


class AllLights(Group):

    """ All the Hue lights connected to your bridge

    This makes use of the semi-documented feature that
    "Group 0" of lights appears to be a group automatically
    consisting of all lights.  This is not returned by
    listing the groups, but is accessible if you explicitly
    ask for group 0.
    """
    def __init__(self, bridge=None):
        if bridge is None:
            bridge = Bridge()
        Group.__init__(self, bridge, 0)


class Scene(object):
    """ Container for Scene """

    def __init__(self, sid, appdata=None, lastupdated=None,
                 lights=None, locked=False, name="", owner="",
                 picture="", recycle=False, version=0, type="", group="",
                 *args, **kwargs):
        self.scene_id = sid
        self.appdata = appdata or {}
        self.lastupdated = lastupdated
        if lights is not None:
            self.lights = sorted([int(x) for x in lights])
        else:
            self.lights = []
        self.locked = locked
        self.name = encodeString(name)
        self.owner = owner
        self.picture = picture
        self.recycle = recycle
        self.version = version
        self.type = type
        self.group = group

    def __repr__(self):
        # like default python repr function, but add scene name
        return '<{0}.{1} id="{2}" name="{3}" lights={4}>'.format(
            self.__class__.__module__,
            self.__class__.__name__,
            self.scene_id,
            self.name,
            self.lights)


class Bridge(object):

    """ Interface to the Hue ZigBee bridge

    You can obtain Light objects by calling the get_light_objects method:

        >>> b = Bridge(ip='192.168.1.100')
        >>> b.get_light_objects()
        [<phue.Light at 0x10473d750>,
         <phue.Light at 0x1046ce110>]

    Or more succinctly just by accessing this Bridge object as a list or dict:

        >>> b[1]
        <phue.Light at 0x10473d750>
        >>> b['Kitchen']
        <phue.Light at 0x10473d750>



    """
    def __init__(self, ip=None, username=None, config_file_path=None):
        """ Initialization function.

        Parameters:
        ------------
        ip : string
            IP address as dotted quad
        username : string, optional

        """

        if config_file_path is not None:
            self.config_file_path = config_file_path
        elif os.getenv(USER_HOME) is not None and os.access(os.getenv(USER_HOME), os.W_OK):
            self.config_file_path = os.path.join(os.getenv(USER_HOME), '.python_hue')
        elif 'iPad' in platform.machine() or 'iPhone' in platform.machine() or 'iPad' in platform.machine():
            self.config_file_path = os.path.join(os.getenv(USER_HOME), 'Documents', '.python_hue')
        else:
            self.config_file_path = os.path.join(os.getcwd(), '.python_hue')

        self.ip = ip
        self.username = username
        self.lights_by_id = {}
        self.lights_by_name = {}
        self.sensors_by_id = {}
        self.sensors_by_name = {}
        self._name = None

        # self.minutes = 600 # these do not seem to be used anywhere?
        # self.seconds = 10

        self.connect()

    @property
    def name(self):
        '''Get or set the name of the bridge [string]'''
        self._name = self.request(
            'GET', '/api/' + self.username + '/config')['name']
        return self._name

    @name.setter
    def name(self, value):
        self._name = value
        data = {'name': self._name}
        self.request(
            'PUT', '/api/' + self.username + '/config', data)

    def request(self, mode='GET', address=None, data=None):
        """ Utility function for HTTP GET/PUT requests for the API"""
        connection = httplib.HTTPConnection(self.ip, timeout=10)

        try:
            if mode == 'GET' or mode == 'DELETE':
                connection.request(mode, address)
            if mode == 'PUT' or mode == 'POST':
                connection.request(mode, address, json.dumps(data))

            logger.debug("{0} {1} {2}".format(mode, address, str(data)))

        except socket.timeout:
            error = "{} Request to {}{} timed out.".format(mode, self.ip, address)

            logger.exception(error)
            raise PhueRequestTimeout(None, error)

        result = connection.getresponse()
        response = result.read()
        connection.close()
        if PY3K:
            response = response.decode('utf-8')

        logger.debug(response)
        return json.loads(response)

    def get_ip_address(self, set_result=False):

        """ Get the bridge ip address from the meethue.com nupnp api """

        connection = httplib.HTTPSConnection('www.meethue.com')
        connection.request('GET', '/api/nupnp')

        logger.info('Connecting to meethue.com/api/nupnp')

        result = connection.getresponse()

        if PY3K:
            data = json.loads(str(result.read(), encoding='utf-8'))
        else:
            result_str = result.read()
            data = json.loads(result_str)

        """ close connection after read() is done, to prevent issues with read() """

        connection.close()

        ip = str(data[0]['internalipaddress'])

        if ip:
            if set_result:
                self.ip = ip

            return ip
        else:
            return False

    def register_app(self):
        """ Register this computer with the Hue bridge hardware and save the resulting access token """
        registration_request = {"devicetype": "python_hue"}
        response = self.request('POST', '/api', registration_request)
        for line in response:
            for key in line:
                if 'success' in key:
                    with open(self.config_file_path, 'w') as f:
                        logger.info(
                            'Writing configuration file to ' + self.config_file_path)
                        f.write(json.dumps({self.ip: line['success']}))
                        logger.info('Reconnecting to the bridge')
                    self.connect()
                if 'error' in key:
                    error_type = line['error']['type']
                    if error_type == 101:
                        raise PhueRegistrationException(error_type,
                                                        'The link button has not been pressed in the last 30 seconds.')
                    if error_type == 7:
                        raise PhueException(error_type,
                                            'Unknown username')

    def connect(self):
        """ Connect to the Hue bridge """
        logger.info('Attempting to connect to the bridge...')
        # If the ip and username were provided at class init
        if self.ip is not None and self.username is not None:
            logger.info('Using ip: ' + self.ip)
            logger.info('Using username: ' + self.username)
            return

        if self.ip is None or self.username is None:
            try:
                with open(self.config_file_path) as f:
                    config = json.loads(f.read())
                    if self.ip is None:
                        self.ip = list(config.keys())[0]
                        logger.info('Using ip from config: ' + self.ip)
                    else:
                        logger.info('Using ip: ' + self.ip)
                    if self.username is None:
                        self.username = config[self.ip]['username']
                        logger.info(
                            'Using username from config: ' + self.username)
                    else:
                        logger.info('Using username: ' + self.username)
            except Exception as e:
                logger.info(
                    'Error opening config file, will attempt bridge registration')
                self.register_app()

    def get_light_id_by_name(self, name):
        """ Lookup a light id based on string name. Case-sensitive. """
        lights = self.get_light()
        for light_id in lights:
            if decodeString(name) == lights[light_id]['name']:
                return light_id
        return False

    def get_light_objects(self, mode='list'):
        """Returns a collection containing the lights, either by name or id (use 'id' or 'name' as the mode)
        The returned collection can be either a list (default), or a dict.
        Set mode='id' for a dict by light ID, or mode='name' for a dict by light name.   """
        if self.lights_by_id == {}:
            lights = self.request('GET', '/api/' + self.username + '/lights/')
            for light in lights:
                self.lights_by_id[int(light)] = Light(self, int(light))
                self.lights_by_name[lights[light][
                    'name']] = self.lights_by_id[int(light)]
        if mode == 'id':
            return self.lights_by_id
        if mode == 'name':
            return self.lights_by_name
        if mode == 'list':
            # return ligts in sorted id order, dicts have no natural order
            return [self.lights_by_id[id] for id in sorted(self.lights_by_id)]

    def get_sensor_id_by_name(self, name):
        """ Lookup a sensor id based on string name. Case-sensitive. """
        sensors = self.get_sensor()
        for sensor_id in sensors:
            if decodeString(name) == sensors[sensor_id]['name']:
                return sensor_id
        return False

    def get_sensor_objects(self, mode='list'):
        """Returns a collection containing the sensors, either by name or id (use 'id' or 'name' as the mode)
        The returned collection can be either a list (default), or a dict.
        Set mode='id' for a dict by sensor ID, or mode='name' for a dict by sensor name.   """
        if self.sensors_by_id == {}:
            sensors = self.request('GET', '/api/' + self.username + '/sensors/')
            for sensor in sensors:
                self.sensors_by_id[int(sensor)] = Sensor(self, int(sensor))
                self.sensors_by_name[sensors[sensor][
                    'name']] = self.sensors_by_id[int(sensor)]
        if mode == 'id':
            return self.sensors_by_id
        if mode == 'name':
            return self.sensors_by_name
        if mode == 'list':
            return self.sensors_by_id.values()

    def __getitem__(self, key):
        """ Lights are accessibly by indexing the bridge either with
        an integer index or string name. """
        if self.lights_by_id == {}:
            self.get_light_objects()

        try:
            return self.lights_by_id[key]
        except:
            try:
                return self.lights_by_name[decodeString(key)]
            except:
                raise KeyError(
                    'Not a valid key (integer index starting with 1, or light name): ' + str(key))

    @property
    def lights(self):
        """ Access lights as a list """
        return self.get_light_objects()

    def get_api(self):
        """ Returns the full api dictionary """
        return self.request('GET', '/api/' + self.username)

    def get_light(self, light_id=None, parameter=None):
        """ Gets state by light_id and parameter"""

        if is_string(light_id):
            light_id = self.get_light_id_by_name(light_id)
        if light_id is None:
            return self.request('GET', '/api/' + self.username + '/lights/')
        state = self.request(
            'GET', '/api/' + self.username + '/lights/' + str(light_id))
        if parameter is None:
            return state
        if parameter in ['name', 'type', 'uniqueid', 'swversion']:
            return state[parameter]
        else:
            try:
                return state['state'][parameter]
            except KeyError as e:
                raise KeyError(
                    'Not a valid key, parameter %s is not associated with light %s)'
                    % (parameter, light_id))

    def set_light(self, light_id, parameter, value=None, transitiontime=None):
        """ Adjust properties of one or more lights.

        light_id can be a single lamp or an array of lamps
        parameters: 'on' : True|False , 'bri' : 0-254, 'sat' : 0-254, 'ct': 154-500
                    'xy' : [0.0-1.0, 0.0-1.0]

        transitiontime : in **deciseconds**, time for this transition to take place
                         Note that transitiontime only applies to *this* light
                         command, it is not saved as a setting for use in the future!
                         Use the Light class' transitiontime attribute if you want
                         persistent time settings.

        """
        if isinstance(parameter, dict):
            data = parameter
        else:
            data = {parameter: value}

        if transitiontime is not None:
            data['transitiontime'] = int(round(
                transitiontime))  # must be int for request format

        light_id_array = light_id
        if isinstance(light_id, int) or is_string(light_id):
            light_id_array = [light_id]
        result = []
        for light in light_id_array:
            logger.debug(str(data))
            if parameter == 'name':
                result.append(self.request('PUT', '/api/' + self.username + '/lights/' + str(
                    light_id), data))
            else:
                if is_string(light):
                    converted_light = self.get_light_id_by_name(light)
                else:
                    converted_light = light
                result.append(self.request('PUT', '/api/' + self.username + '/lights/' + str(
                    converted_light) + '/state', data))
            if 'error' in list(result[-1][0].keys()):
                logger.warn("ERROR: {0} for light {1}".format(
                    result[-1][0]['error']['description'], light))

        logger.debug(result)
        return result

    # Sensors #####

    @property
    def sensors(self):
        """ Access sensors as a list """
        return self.get_sensor_objects()

    def create_sensor(self, name, modelid, swversion, sensor_type, uniqueid, manufacturername, state={}, config={}, recycle=False):
        """ Create a new sensor in the bridge. Returns (ID,None) of the new sensor or (None,message) if creation failed. """
        data = {
            "name": name,
            "modelid": modelid,
            "swversion": swversion,
            "type": sensor_type,
            "uniqueid": uniqueid,
            "manufacturername": manufacturername,
            "recycle": recycle
        }
        if (isinstance(state, dict) and state != {}):
            data["state"] = state

        if (isinstance(config, dict) and config != {}):
            data["config"] = config

        result = self.request('POST', '/api/' + self.username + '/sensors/', data)

        if ("success" in result[0].keys()):
            new_id = result[0]["success"]["id"]
            logger.debug("Created sensor with ID " + new_id)
            new_sensor = Sensor(self, int(new_id))
            self.sensors_by_id[new_id] = new_sensor
            self.sensors_by_name[name] = new_sensor
            return new_id, None
        else:
            logger.debug("Failed to create sensor:" + repr(result[0]))
            return None, result[0]

    def get_sensor(self, sensor_id=None, parameter=None):
        """ Gets state by sensor_id and parameter"""

        if is_string(sensor_id):
            sensor_id = self.get_sensor_id_by_name(sensor_id)
        if sensor_id is None:
            return self.request('GET', '/api/' + self.username + '/sensors/')
        data = self.request(
            'GET', '/api/' + self.username + '/sensors/' + str(sensor_id))

        if isinstance(data, list):
            logger.debug("Unable to read sensor with ID {0}: {1}".format(sensor_id, repr(data)))
            return None

        if parameter is None:
            return data
        return data[parameter]

    def set_sensor(self, sensor_id, parameter, value=None):
        """ Adjust properties of a sensor

        sensor_id must be a single sensor.
        parameters: 'name' : string

        """
        if isinstance(parameter, dict):
            data = parameter
        else:
            data = {parameter: value}

        result = None
        logger.debug(str(data))
        result = self.request('PUT', '/api/' + self.username + '/sensors/' + str(
            sensor_id), data)
        if 'error' in list(result[0].keys()):
            logger.warn("ERROR: {0} for sensor {1}".format(
                result[0]['error']['description'], sensor_id))

        logger.debug(result)
        return result

    def set_sensor_state(self, sensor_id, parameter, value=None):
        """ Adjust the "state" object of a sensor

        sensor_id must be a single sensor.
        parameters: any parameter(s) present in the sensor's "state" dictionary.

        """
        self.set_sensor_content(sensor_id, parameter, value, "state")

    def set_sensor_config(self, sensor_id, parameter, value=None):
        """ Adjust the "config" object of a sensor

        sensor_id must be a single sensor.
        parameters: any parameter(s) present in the sensor's "config" dictionary.

        """
        self.set_sensor_content(sensor_id, parameter, value, "config")

    def set_sensor_content(self, sensor_id, parameter, value=None, structure="state"):
        """ Adjust the "state" or "config" structures of a sensor
        """
        if (structure != "state" and structure != "config"):
            logger.debug("set_sensor_current expects structure 'state' or 'config'.")
            return False

        if isinstance(parameter, dict):
            data = parameter.copy()
        else:
            data = {parameter: value}

        # Attempting to set this causes an error.
        if "lastupdated" in data:
            del data["lastupdated"]

        result = None
        logger.debug(str(data))
        result = self.request('PUT', '/api/' + self.username + '/sensors/' + str(
            sensor_id) + "/" + structure, data)
        if 'error' in list(result[0].keys()):
            logger.warn("ERROR: {0} for sensor {1}".format(
                result[0]['error']['description'], sensor_id))

        logger.debug(result)
        return result

    def delete_sensor(self, sensor_id):
        try:
            name = self.sensors_by_id[sensor_id].name
            del self.sensors_by_name[name]
            del self.sensors_by_id[sensor_id]
            return self.request('DELETE', '/api/' + self.username + '/sensors/' + str(sensor_id))
        except:
            logger.debug("Unable to delete nonexistent sensor with ID {0}".format(sensor_id))

    # Groups of lights #####
    @property
    def groups(self):
        """ Access groups as a list """
        return [Group(self, int(groupid)) for groupid in self.get_group().keys()]

    def get_group_id_by_name(self, name):
        """ Lookup a group id based on string name. Case-sensitive. """
        groups = self.get_group()
        for group_id in groups:
            if decodeString(name) == groups[group_id]['name']:
                return int(group_id)
        return False

    def get_group(self, group_id=None, parameter=None):
        if is_string(group_id):
            group_id = self.get_group_id_by_name(group_id)
        if group_id is False:
            logger.error('Group name does not exist')
            return
        if group_id is None:
            return self.request('GET', '/api/' + self.username + '/groups/')
        if parameter is None:
            return self.request('GET', '/api/' + self.username + '/groups/' + str(group_id))
        elif parameter == 'name' or parameter == 'lights':
            return self.request('GET', '/api/' + self.username + '/groups/' + str(group_id))[parameter]
        elif parameter in ('any_on', 'all_on'):
            return self.request('GET', '/api/' + self.username + '/groups/' + str(group_id))['state'][parameter]
        else:
            return self.request('GET', '/api/' + self.username + '/groups/' + str(group_id))['action'][parameter]

    def set_group(self, group_id, parameter, value=None, transitiontime=None):
        """ Change light settings for a group

        group_id : int, id number for group
        parameter : 'name' or 'lights'
        value: string, or list of light IDs if you're setting the lights

        """

        if isinstance(parameter, dict):
            data = parameter
        elif parameter == 'lights' and (isinstance(value, list) or isinstance(value, int)):
            if isinstance(value, int):
                value = [value]
            data = {parameter: [str(x) for x in value]}
        else:
            data = {parameter: value}

        if transitiontime is not None:
            data['transitiontime'] = int(round(
                transitiontime))  # must be int for request format

        group_id_array = group_id
        if isinstance(group_id, int) or is_string(group_id):
            group_id_array = [group_id]
        result = []
        for group in group_id_array:
            logger.debug(str(data))
            if is_string(group):
                converted_group = self.get_group_id_by_name(group)
            else:
                converted_group = group
            if converted_group is False:
                logger.error('Group name does not exist')
                return
            if parameter == 'name' or parameter == 'lights':
                result.append(self.request('PUT', '/api/' + self.username + '/groups/' + str(converted_group), data))
            else:
                result.append(self.request('PUT', '/api/' + self.username + '/groups/' + str(converted_group) + '/action', data))

        if 'error' in list(result[-1][0].keys()):
            logger.warn("ERROR: {0} for group {1}".format(
                result[-1][0]['error']['description'], group))

        logger.debug(result)
        return result

    def create_group(self, name, lights=None):
        """ Create a group of lights

        Parameters
        ------------
        name : string
            Name for this group of lights
        lights : list
            List of lights to be in the group.

        """
        data = {'lights': [str(x) for x in lights], 'name': name}
        return self.request('POST', '/api/' + self.username + '/groups/', data)

    def delete_group(self, group_id):
        return self.request('DELETE', '/api/' + self.username + '/groups/' + str(group_id))

    # Scenes #####
    @property
    def scenes(self):
        return [Scene(k, **v) for k, v in self.get_scene().items()]

    def create_group_scene(self, name, group):
        """Create a Group Scene

        Group scenes are based on the definition of groups and contain always all
        lights from the selected group. No other lights from other rooms can be
        added to a group scene and the group scene can not contain less lights
        as available in the selected group. If a group is extended with new lights,
        the new lights are added with default color to all group scenes based on
        the corresponding group. This app has no influence on this behavior, it
        was defined by Philips.

        :param name: The name of the scene to be created
        :param group: The group id of where the scene will be added
        :return:
        """
        data = {
            "name": name,
            "group": group,
            "recycle": True,
            "type": "GroupScene"
        }
        return self.request('POST', '/api/' + self.username + '/scenes', data)

    def modify_scene(self, scene_id, data):
        return self.request('PUT', '/api/' + self.username + '/scenes/' + scene_id, data)

    def get_scene(self):
        return self.request('GET', '/api/' + self.username + '/scenes')

    def activate_scene(self, group_id, scene_id, transition_time=4):
        return self.request('PUT', '/api/' + self.username + '/groups/' +
                            str(group_id) + '/action',
                            {
                                "scene": scene_id,
                                "transitiontime": transition_time
                            })

    def run_scene(self, group_name, scene_name, transition_time=4):
        """Run a scene by group and scene name.

        As of 1.11 of the Hue API the scenes are accessable in the
        API. With the gen 2 of the official HUE app everything is
        organized by room groups.

        This provides a convenience way of activating scenes by group
        name and scene name. If we find exactly 1 group and 1 scene
        with the matching names, we run them.

        If we find more than one we run the first scene who has
        exactly the same lights defined as the group. This is far from
        perfect, but is convenient for setting lights symbolically (and
        can be improved later).

        :param transition_time: The duration of the transition from the
        light’s current state to the new state in a multiple of 100ms
        :returns True if a scene was run, False otherwise

        """
        groups = [x for x in self.groups if x.name == group_name]
        scenes = [x for x in self.scenes if x.name == scene_name]
        if len(groups) != 1:
            logger.warn("run_scene: More than 1 group found by name {}".format(group_name))
            return False
        group = groups[0]
        if len(scenes) == 0:
            logger.warn("run_scene: No scene found {}".format(scene_name))
            return False
        if len(scenes) == 1:
            self.activate_scene(group.group_id, scenes[0].scene_id, transition_time)
            return True
        # otherwise, lets figure out if one of the named scenes uses
        # all the lights of the group
        group_lights = sorted([x.light_id for x in group.lights])
        for scene in scenes:
            if group_lights == scene.lights:
                self.activate_scene(group.group_id, scene.scene_id, transition_time)
                return True
        logger.warn("run_scene: did not find a scene: {} "
                    "that shared lights with group {}".format(scene_name, group_name))
        return False

    def delete_scene(self, scene_id):
        try:
            return self.request('DELETE', '/api/' + self.username + '/scenes/' + str(scene_id))
        except:
            logger.debug("Unable to delete scene with ID {0}".format(scene_id))

    # Schedules #####
    def get_schedule(self, schedule_id=None, parameter=None):
        if schedule_id is None:
            return self.request('GET', '/api/' + self.username + '/schedules')
        if parameter is None:
            return self.request('GET', '/api/' + self.username + '/schedules/' + str(schedule_id))

    def create_schedule(self, name, time, light_id, data, description=' '):
        schedule = {
            'name': name,
            'localtime': time,
            'description': description,
            'command':
            {
                'method': 'PUT',
                'address': ('/api/' + self.username +
                            '/lights/' + str(light_id) + '/state'),
                'body': data
            }
        }
        return self.request('POST', '/api/' + self.username + '/schedules', schedule)

    def set_schedule_attributes(self, schedule_id, attributes):
        """
        :param schedule_id: The ID of the schedule
        :param attributes: Dictionary with attributes and their new values
        """
        return self.request('PUT', '/api/' + self.username + '/schedules/' + str(schedule_id), data=attributes)

    def create_group_schedule(self, name, time, group_id, data, description=' '):
        schedule = {
            'name': name,
            'localtime': time,
            'description': description,
            'command':
            {
                'method': 'PUT',
                'address': ('/api/' + self.username +
                            '/groups/' + str(group_id) + '/action'),
                'body': data
            }
        }
        return self.request('POST', '/api/' + self.username + '/schedules', schedule)

    def delete_schedule(self, schedule_id):
        return self.request('DELETE', '/api/' + self.username + '/schedules/' + str(schedule_id))

if __name__ == '__main__':
    import argparse

    logging.basicConfig(level=logging.DEBUG)

    parser = argparse.ArgumentParser()
    parser.add_argument('--host', required=True)
    parser.add_argument('--config-file-path', required=False)
    args = parser.parse_args()

    while True:
        try:
            b = Bridge(args.host, config_file_path=args.config_file_path)
            break
        except PhueRegistrationException as e:
            if PY3K:
                input('Press button on Bridge then hit Enter to try again')
            else:
                raw_input('Press button on Bridge then hit Enter to try again')  # noqa


Repository: studioimaginaire/phue
File: phue.sublime-project

{
	"folders":
	[
		{
			"follow_symlinks": true,
			"path": "../phue"
		}
	]
}


Repository: studioimaginaire/phue
File: setup.py

# -*- coding: utf-8 -*-

from phue import __version__
from distutils.core import setup

setup(
    name = 'phue',
    version = __version__,
    description = 'A Philips Hue Python library',
    author = 'Nathanaël Lécaudé',
    license='MIT',
    url = 'https://github.com/studioimaginaire/phue',
    py_modules=['phue'],
)


Repository: studioimaginaire/phue
File: test-requirements.txt

py27: mock
pytest>=2.9.2
pytest-cov>=2.3.1
pytest-timeout>=1.0.0
testtools


Repository: studioimaginaire/phue
File: tests/fakes.py

import json
import sys
import samples

if sys.version_info[0] > 2:
    from io import BytesIO as StringIO
    def dump(data):
        return json.dumps(data).encode('utf-8')
else:
    from StringIO import StringIO
    def dump(data):
       return json.dumps(data)


class Request(object):
    def __init__(self, mode, addr, data):
        self.mode = mode
        self.addr = addr
        self.data = data


class FakeHTTP(object):

    def __init__(self, *args, **kwargs):
        super(FakeHTTP, self).__init__()
        self.call = None

    def request(self, mode, addr, data=None):
        self.call = Request(mode, addr, data)

    def getresponse(self):
        data = samples.RESP[self.call.mode][self.call.addr]
        return StringIO(dump(data))

    def close(self):
        pass


Repository: studioimaginaire/phue
File: tests/samples.py

LIGHTS1 = {
    u'1': {u'manufacturername': u'Philips',
           u'modelid': u'LCT001',
           u'name': u'Living Room Bulb',
           u'state': {u'alert': u'none',
                      u'bri': 254,
                      u'colormode': u'xy',
                      u'ct': 382,
                      u'effect': u'none',
                      u'hue': 14665,
                      u'on': True,
                      u'reachable': True,
                      u'sat': 156,
                      u'xy': [0.4677, 0.4121]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Extended color light',
           u'uniqueid': u'00:17:88:01:00:d1:fd:53-0b'},
    u'10': {u'manufacturername': u'Philips',
            u'modelid': u'LCT001',
            u'name': u'Porch 4',
            u'state': {u'alert': u'none',
                       u'bri': 117,
                       u'colormode': u'xy',
                       u'ct': 500,
                       u'effect': u'none',
                       u'hue': 11004,
                       u'on': False,
                       u'reachable': True,
                       u'sat': 252,
                       u'xy': [0.5593, 0.406]},
            u'swversion': u'5.23.1.13452',
            u'type': u'Extended color light',
            u'uniqueid': u'00:17:88:01:00:ec:74:ab-0b'},
    u'11': {u'manufacturername': u'Philips',
            u'modelid': u'LST002',
            u'name': u'Living Room light strips',
            u'state': {u'alert': u'none',
                       u'bri': 254,
                       u'colormode': u'xy',
                       u'ct': 389,
                       u'effect': u'none',
                       u'hue': 64967,
                       u'on': True,
                       u'reachable': True,
                       u'sat': 79,
                       u'xy': [0.472, 0.353]},
            u'swversion': u'5.50.2.19072',
            u'type': u'Extended color light',
            u'uniqueid': u'00:17:88:01:01:1a:22:cd-0b'},
    u'12': {u'manufacturername': u'Philips',
            u'modelid': u'LCT007',
            u'name': u'Arwen Dresser',
            u'state': {u'alert': u'none',
                       u'bri': 251,
                       u'colormode': u'xy',
                       u'ct': 403,
                       u'effect': u'none',
                       u'hue': 14314,
                       u'on': False,
                       u'reachable': True,
                       u'sat': 172,
                       u'xy': [0.4791, 0.4139]},
            u'swversion': u'5.50.1.19085',
            u'type': u'Extended color light',
            u'uniqueid': u'00:17:88:01:10:47:9a:fe-0b'},
    u'13': {u'manufacturername': u'Philips',
            u'modelid': u'LCT007',
            u'name': u'Arwen Changing Table',
            u'state': {u'alert': u'none',
                       u'bri': 117,
                       u'colormode': u'xy',
                       u'ct': 488,
                       u'effect': u'none',
                       u'hue': 12713,
                       u'on': False,
                       u'reachable': True,
                       u'sat': 222,
                       u'xy': [0.5224, 0.414]},
            u'swversion': u'5.50.1.19085',
            u'type': u'Extended color light',
            u'uniqueid': u'00:17:88:01:10:31:ee:f0-0b'},
    u'2': {u'manufacturername': u'Philips',
           u'modelid': u'LCT001',
           u'name': u'Bedroom Susan',
           u'state': {u'alert': u'none',
                      u'bri': 117,
                      u'colormode': u'xy',
                      u'ct': 153,
                      u'effect': u'none',
                      u'hue': 52067,
                      u'on': False,
                      u'reachable': True,
                      u'sat': 237,
                      u'xy': [0.3089, 0.1334]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Extended color light',
           u'uniqueid': u'00:17:88:01:00:f9:02:ae-0b'},
    u'3': {u'manufacturername': u'Philips',
           u'modelid': u'LCT001',
           u'name': u'Bedroom Sean',
           u'state': {u'alert': u'none',
                      u'bri': 117,
                      u'colormode': u'xy',
                      u'ct': 153,
                      u'effect': u'none',
                      u'hue': 52067,
                      u'on': False,
                      u'reachable': True,
                      u'sat': 237,
                      u'xy': [0.3089, 0.1334]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Extended color light',
           u'uniqueid': u'00:17:88:01:00:fe:00:e3-0b'},
    u'4': {u'manufacturername': u'Philips',
           u'modelid': u'LLC010',
           u'name': u'Living Room Iris',
           u'state': {u'alert': u'none',
                      u'bri': 254,
                      u'colormode': u'xy',
                      u'effect': u'none',
                      u'hue': 58619,
                      u'on': True,
                      u'reachable': True,
                      u'sat': 81,
                      u'xy': [0.4715, 0.3499]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Color light',
           u'uniqueid': u'00:17:88:01:00:12:01:83-0b'},
    u'5': {u'manufacturername': u'Philips',
           u'modelid': u'LST001',
           u'name': u'Living Room Dim Strip',
           u'state': {u'alert': u'none',
                      u'bri': 254,
                      u'colormode': u'xy',
                      u'effect': u'none',
                      u'hue': 58619,
                      u'on': True,
                      u'reachable': True,
                      u'sat': 81,
                      u'xy': [0.4715, 0.3499]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Color light',
           u'uniqueid': u'00:17:88:01:00:cd:b2:03-0b'},
    u'6': {u'manufacturername': u'Philips',
           u'modelid': u'LLC011',
           u'name': u'Arwen Flower',
           u'state': {u'alert': u'none',
                      u'bri': 3,
                      u'colormode': u'xy',
                      u'effect': u'none',
                      u'hue': 64654,
                      u'on': True,
                      u'reachable': True,
                      u'sat': 249,
                      u'xy': [0.6855, 0.2927]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Color light',
           u'uniqueid': u'00:17:88:01:00:c5:23:7e-0b'},
    u'7': {u'manufacturername': u'Philips',
           u'modelid': u'LCT001',
           u'name': u'Porch Fan 1',
           u'state': {u'alert': u'none',
                      u'bri': 117,
                      u'colormode': u'xy',
                      u'ct': 500,
                      u'effect': u'none',
                      u'hue': 11004,
                      u'on': False,
                      u'reachable': True,
                      u'sat': 252,
                      u'xy': [0.5593, 0.406]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Extended color light',
           u'uniqueid': u'00:17:88:01:00:fe:8a:df-0b'},
    u'8': {u'manufacturername': u'Philips',
           u'modelid': u'LCT001',
           u'name': u'Porch Fan 2',
           u'state': {u'alert': u'none',
                      u'bri': 117,
                      u'colormode': u'xy',
                      u'ct': 500,
                      u'effect': u'none',
                      u'hue': 11004,
                      u'on': False,
                      u'reachable': True,
                      u'sat': 252,
                      u'xy': [0.5593, 0.406]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Extended color light',
           u'uniqueid': u'00:17:88:01:00:f9:88:37-0b'},
    u'9': {u'manufacturername': u'Philips',
           u'modelid': u'LCT001',
           u'name': u'Porch 3',
           u'state': {u'alert': u'none',
                      u'bri': 117,
                      u'colormode': u'xy',
                      u'ct': 500,
                      u'effect': u'none',
                      u'hue': 11004,
                      u'on': False,
                      u'reachable': True,
                      u'sat': 252,
                      u'xy': [0.5593, 0.406]},
           u'swversion': u'5.23.1.13452',
           u'type': u'Extended color light',
           u'uniqueid': u'00:17:88:01:00:fe:88:17-0b'}}

RESP = dict(GET=dict(), POST=dict(), PUT=dict(), DELETE=dict())
RESP['GET']['/api/username/lights/'] = LIGHTS1
for key, value in LIGHTS1.items():
    RESP['GET']['/api/username/lights/%s' % key] = LIGHTS1[key]


Repository: studioimaginaire/phue
File: tests/test_basic_import.py

# Published under the MIT license - See LICENSE file for more detail
#
# This is a basic test file which just tests that things import, which
# means that this is even vaguely python code.

import testtools

import phue  # noqa


class TestImport(testtools.TestCase):

    def test_import_works(self):
        pass


Repository: studioimaginaire/phue
File: tests/test_request.py

# Published under the MIT license - See LICENSE file for more detail
#
# This is a basic test file which just tests that things import, which
# means that this is even vaguely python code.

import fixtures
import os
import sys
import testtools

try:
    from unittest import mock
except ImportError:
    import mock

import phue
import fakes

if sys.version_info[0] > 2:
    httplib = 'http.client.HTTPConnection'
else:
    httplib = 'httplib.HTTPConnection'


class TestRequest(testtools.TestCase):

    def setUp(self):
        super(TestRequest, self).setUp()
        self.home = fixtures.TempHomeDir()
        self.useFixture(self.home)

    def test_register(self):
        """test that registration happens automatically during setup."""
        confname = os.path.join(self.home.path, '.python_hue')
        with mock.patch("phue.Bridge.request") as req:
            req.return_value = [{'success': {'username': 'fooo'}}]
            bridge = phue.Bridge(ip="10.0.0.0")
            self.assertEqual(bridge.config_file_path, confname)

        # check contents of file
        with open(confname) as f:
            contents = f.read()
            self.assertEqual(contents, '{"10.0.0.0": {"username": "fooo"}}')

        # make sure we can open under a different file
        bridge2 = phue.Bridge(ip="10.0.0.0")
        self.assertEqual(bridge2.username, "fooo")

        # and that we can even open without an ip address
        bridge3 = phue.Bridge()
        self.assertEqual(bridge3.username, "fooo")
        self.assertEqual(bridge3.ip, "10.0.0.0")

    def test_register_fail(self):
        """Test that registration fails in the expected way for timeout"""
        with mock.patch("phue.Bridge.request") as req:
            req.return_value = [{'error': {'type': 101}}]
            self.assertRaises(phue.PhueRegistrationException,
                              phue.Bridge, ip="10.0.0.0")

    def test_register_unknown_user(self):
        """Test that registration for unknown user works."""
        with mock.patch("phue.Bridge.request") as req:
            req.return_value = [{'error': {'type': 7}}]
            self.assertRaises(phue.PhueException,
                              phue.Bridge, ip="10.0.0.0")


class TestLights(testtools.TestCase):

    def setUp(self):
        super(TestLights, self).setUp()
        self.useFixture(fixtures.MonkeyPatch(httplib, fakes.FakeHTTP))
        self.bridge = phue.Bridge(ip="10.0.0.0", username="username")

    def test_get_lights(self):
        lights = self.bridge.get_light_objects('id')
        self.assertEqual(lights[1].name, "Living Room Bulb")


Repository: studioimaginaire/phue
File: tox.ini

[tox]
envlist = pep8, py27, py35
skip_missing_interpreters = True

[testenv]
setenv =
    LANG=en_US.UTF-8
    PYTHONPATH = {toxinidir}
commands =
     py.test -v --timeout=30 --duration=10 --cov=phue --cov-report html {posargs}
deps =
     -r{toxinidir}/test-requirements.txt

[testenv:pep8]
deps = flake8
basepython = python3
commands =
     flake8 phue.py

[flake8]
ignore = E501
exclude =  .venv,.git,.tox,dist,doc,*lib/python*,*egg,build


